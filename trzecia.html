<!DOCTYPE html>
<html lang="pl">
<head>
  <meta charset="UTF-8" />
  <title>BK Pegasus PRO</title>
  <style>
    body {
      background-color: #121212;
      color: #f0f0f0;
      font-family: Arial, sans-serif;
      padding: 20px;
      margin: auto;
      overflow-x: auto;
    }
    textarea {
      width: 100%;
      height: 200px;
      background: #1e1e1e;
      color: #fff;
      border: 1px solid #333;
      padding: 10px;
      margin-bottom: 10px;
      font-family: monospace;
      resize: vertical;
    }
    button {
      padding: 10px 15px;
      background-color: #fbbc04;
      border: none;
      color: #121212;
      cursor: pointer;
      margin-right: 5px;
      border-radius: 6px;
      font-weight: bold;
      transition: background-color 0.3s ease;
    }
    button:hover { background-color: #d9a403; }
    #resetBtn { background-color: #e53935; color: #fff; }
    #resetBtn:hover { background-color: #c62828; }
/* NOWY STYL DLA MODALU PODSUMOWANIA GRACZA */
    #playerSummaryModal {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.7);
        display: none; /* Domy≈õlnie ukryty */
        justify-content: center;
        align-items: center;
        z-index: 1000;
    }
    #playerSummaryContent {
        background-color: #1e1e1e;
        padding: 20px 30px;
        border-radius: 8px;
        width: 80%;
        max-width: 600px;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
        max-height: 90vh;
        overflow-y: auto;
        color: #f0f0f0;
    }
    #playerSummaryContent h2 {
        color: #fbbc04;
        margin-top: 0;
        border-bottom: 2px solid #333;
        padding-bottom: 10px;
        margin-bottom: 15px;
    }
    #playerSummaryContent h3 {
        color: #ffd28a;
        margin: 15px 0 8px 0;
    }
    .summary-grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 10px 20px;
    }
    .summary-grid-item {
        display: flex;
        justify-content: space-between;
        padding: 5px 0;
        border-bottom: 1px dotted #333;
    }
table {
  width: 100%;
  border-collapse: collapse;
  margin-top: 20px;
  background: transparent;   /* tabela niewidoczna */
  white-space: nowrap;
}

th, td {
  border: none;              /* brak linii miƒôdzy kolumnami */
  padding: 8px;
  text-align: center;
  color: #ddd;
}

th {
  background-color: #fbbc04;
  color: #222;
  position: sticky;
  top: 0;
  z-index: 2;
  cursor: pointer;
}

/* naprzemienne wiersze */
tbody tr:nth-child(odd)  { background-color: #000; }       /* czarny */
tbody tr:nth-child(even) { background-color: #121212; }    /* dok≈Çadnie t≈Ço strony */


    /* Kolory r√≥≈ºnic */
    .diff-pos { color: #32ff32; }   /* zielony */
    .diff-neg { color: #f44336; }   /* czerwony */
    .zero-diff { color: #2196f3; }  /* niebieski */
    .draws-diff { color: #00d5ff; } /* b≈Çƒôkitny remis */

    /* Pod≈õwietlenie zaznaczonego wiersza */
    .highlighted { color: #ffb347 !important; font-weight: bold; }

    /* Prawy panel alias√≥w */
    #aliasManager {
      background: #1e1e1e;
      border: 1px solid #333;
      border-radius: 6px;
      padding: 10px;
      height: 200px;
      overflow-y: auto;
    }
    #aliasManager h3 { margin: 0 0 8px 0; font-size: 14px; color: #ffd28a; }
    #aliasManager table { width: 100%; margin-top: 10px; border-collapse: collapse; }
    #aliasManager th, #aliasManager td { border: 1px solid #333; padding: 6px; text-align: center; }
    #aliasManager th { background-color: #fbbc04; color: #121212; font-weight: bold; }
    #aliasManager tbody tr:nth-child(odd) { background-color: #000; color: #fff; }
    #aliasManager tbody tr:nth-child(even) { background-color: #1a1a1a; color: #fff; }

#dataTable td {
  transition: background-color 0.3s ease;
}

    /* Kontener 80/20 */
    .topbar { display: flex; gap: 10px; align-items: stretch; margin-bottom: 10px; }
    .topbar .left { flex: 4; }
    .topbar .right { flex: 1; }
    
    /* Nowy styl dla selecta checkpoint */
    #globalCheckpointSelect {
        padding: 8px 12px;
        margin-left: 5px;
        background-color: #1e1e1e;
        color: #f0f0f0;
        border: 1px solid #333;
        border-radius: 6px;
        cursor: pointer;
    }
    #globalCheckpointSelect option {
        background-color: #1e1e1e;
        color: #f0f0f0;
    }
  </style>
</head>
<body>

<h1>BK Pegasus - Ultimate v12.2025</h1>

<div class="topbar">
  <div class="left">
    <textarea id="inputHTML" placeholder="Wklej tutaj wiele profili HTML..."></textarea>
  </div>
  <div class="right">
    <div id="aliasManager"></div>
  </div>
</div>

<button id="extractBtn" onclick="extractMultipleAndClear()">WyciƒÖgnij dane</button>
<button onclick="saveCheckpointAndClear()">Zapisz checkpoint</button>
<button id="resetBtn" onclick="resetCheckpoint()">RESET</button>
<button id="toggleAttrBtn" onclick="toggleAttributes()">Ukryj atrybuty</button>
<button id="toggleTournamentsBtn" onclick="toggleTournaments()">Ukryj turnieje</button>
<button id="toggleStatsBtn" onclick="toggleStatsColumns()">Ukryj poziom, ≈Çupy i walki</button>
<button style="background-color:#2196f3;color:#fff;" onclick="copyChangedRows()">Kopiuj</button>
<button id="toggleExtraBtn" style="background-color:#4caf50; color:#fff;" onclick="toggleExtraColumns()">Wiƒôcej danych</button>
<button id="showSummaryBtn" style="background-color:#9c27b0; color:#fff;" onclick="showGuildSummary()">Podsumowanie Zakon√≥w</button>
<button id="saveGlobalCheckpointBtn" style="background-color:#ff9800; color:#fff;" onclick="promptAndSaveGlobalCheckpoint()">Trwa≈Çy Checkpoint</button>
<select id="globalCheckpointSelect" onchange="loadGlobalCheckpoint(this.value)">
    <option value="">Wybierz Globalny...</option>
</select>
<button id="deleteGlobalCheckpointBtn" style="background-color:#ea4335; color:#fff;" onclick="deleteSelectedGlobalCheckpoint()">Usu≈Ñ Checkpoint</button>


<div id="result"></div>

<div id="playerSummaryModal" onclick="this.style.display='none'">
    <div id="playerSummaryContent" onclick="event.stopPropagation()">
        <button style="float:right; background-color:#e53935; color:#fff;" onclick="document.getElementById('playerSummaryModal').style.display='none'">Zamknij</button>
        <h2>Szczeg√≥≈Çowe Podsumowanie Gracza</h2>
        <div id="summaryDetails"></div>
    </div>
</div>

<script>
const attrKeys = [
  "Si≈Ça",
  "Zrƒôczno≈õƒá",
  "Kondycja",
  "Szczƒô≈õcie",
  "U≈ºywanie broni",
  "Umiejƒôtno≈õci obronne"
];
const displayNames = {
  "U≈ºywanie broni": "UB",
  "Umiejƒôtno≈õci obronne": "UO",
  "Wygranych turniej√≥w": "Turnieje"
};

const statKeys = {
  "Poziom:": "Poziom",
  "≈Åup \\(zdobyty\\):": "≈Åup zdobyty",
  "≈Åup \\(stracony\\):": "≈Åup stracony",
  "Wygranych turniej&oacute;w:": "Wygranych turniej√≥w",
  "Zwyciƒôstwa:": "Zwyciƒôstwa",
  "Remisy:": "Remisy",
  "Pora≈ºki:": "Pora≈ºki"
};

// ==========================================================
// üî• OPYMALIZACJA: PREKOMPILOWANE WYRA≈ªENIA REGULARNE (START)
// ==========================================================
const REGEX_NICK = /<div>\s*.*?<br\s*\/?>\s*([^<]+)\s*<\/div>/i;
const REGEX_ZAKON = /<th[^>]*>\s*Zakon\s*<\/th>\s*<td[^>]*>\s*<a[^>]*>([^<]+)<\/a>/i;
const REGEX_MODIFY_LUCK = /"ModifyLuck"\s*:\s*(\d+)/i;
const REGEX_ITEM_TIPS = /item\.store\('tip:text',\s*'(.*?)'\);/gs;

const REGEX_BASE_ATTRS = {};
for (const attr of attrKeys) {
    // Regex dla atrybutu bazowego: <th[^>]*>\s*Si≈Ça\s*<\/th>\s*<td[^>]*>(\d+)
    REGEX_BASE_ATTRS[attr] = new RegExp(`<th[^>]*>\\s*${attr}\\s*<\\/th>\\s*<td[^>]*>\\s*(\\d+)`, "i");
}

const REGEX_STATS = {};
for (const key in statKeys) {
    // Regex dla statystyki: <th[^>]*>\s*Poziom:\s*<\/th>\s*<td[^>]*>([\d\.]+)
    REGEX_STATS[key] = new RegExp(`<th[^>]*>\\s*${key}\\s*<\\/th>\\s*<td[^>]*>\\s*([\\d\.]+)`, "i");
}
// ==========================================================
// üî• OPYMALIZACJA: PREKOMPILOWANE WYRA≈ªENIA REGULARNE (KONIEC)
// ==========================================================


// Globalna flaga stanu widoczno≈õci podsumowania
let guildSummaryVisible = false;

// ===== CHECKPOINT I PAMIƒòƒÜ GLOBALNA (NOWE/ZMODYFIKOWANE) =====

const LOCAL_CHECKPOINT_KEY = "bkCheckpoint";
const GLOBAL_CHECKPOINTS_KEY = "bkGlobalCheckpoints";
const CURRENT_ACTIVE_CHECKPOINT_KEY = "bkActiveCheckpointKey";

// Inicjalizacja selecta przy ≈Çadowaniu strony
document.addEventListener('DOMContentLoaded', (event) => {
    initGlobalCheckpoints();
});

// Pobiera aktywny (lokalny lub globalny) checkpoint
function getActiveCheckpointKey() {
    return localStorage.getItem(CURRENT_ACTIVE_CHECKPOINT_KEY) || LOCAL_CHECKPOINT_KEY;
}

// ≈Åaduje checkpoint z wybranego klucza (lokalnego lub globalnego)
function loadCheckpointData(key) {
    if (key === LOCAL_CHECKPOINT_KEY) {
        return JSON.parse(localStorage.getItem(LOCAL_CHECKPOINT_KEY) || "{}");
    } else {
        const globals = JSON.parse(localStorage.getItem(GLOBAL_CHECKPOINTS_KEY) || "{}");
        return globals[key] || {};
    }
}

// Inicjalizacja selecta globalnych checkpoint√≥w
function initGlobalCheckpoints() {
    const select = document.getElementById('globalCheckpointSelect');
    const globals = JSON.parse(localStorage.getItem(GLOBAL_CHECKPOINTS_KEY) || "{}");
    const activeKey = getActiveCheckpointKey();

    // Wyczy≈õƒá stare opcje (opr√≥cz pierwszej)
    while (select.options.length > 1) { select.remove(1); }

    // Dodaj opcje z pamiƒôci globalnej
    for (const key in globals) {
        const option = document.createElement('option');
        option.value = key;
        option.text = key;
        select.add(option);
    }
    
    // Ustawienie aktywnej opcji
    select.value = activeKey === LOCAL_CHECKPOINT_KEY ? "" : activeKey;
}

// Funkcja prze≈ÇƒÖczania na globalny checkpoint
function loadGlobalCheckpoint(key) {
    if (!key) {
        // Prze≈ÇƒÖczenie z powrotem na lokalny checkpoint
        localStorage.setItem(CURRENT_ACTIVE_CHECKPOINT_KEY, LOCAL_CHECKPOINT_KEY);
        alert("Prze≈ÇƒÖczono na lokalny checkpoint.");
    } else {
        localStorage.setItem(CURRENT_ACTIVE_CHECKPOINT_KEY, key);
        alert(`Aktywny checkpoint: ${key}`);
    }
    
    // Pr√≥ba ponownego wyodrƒôbnienia danych z pola tekstowego, je≈õli nie jest puste
    if (document.getElementById("inputHTML").value.trim()) {
        extractMultiple();
    }
}


// Zapisuje obecny stan do nowej, trwa≈Çej nazwy
function promptAndSaveGlobalCheckpoint() {
    if (!window.currentData) { alert("Brak danych do zapisu. Najpierw wyciƒÖgnij dane."); return; }
    
    let checkpointName = prompt("Podaj nazwƒô dla trwa≈Çego checkpointa (np. 'Start Sezonu'):");
    
    if (!checkpointName || !checkpointName.trim()) {
        alert("Anulowano zapis.");
        return;
    }

    checkpointName = checkpointName.trim();
    const globals = JSON.parse(localStorage.getItem(GLOBAL_CHECKPOINTS_KEY) || "{}");

    // Zapisz obecny stan do globalnej pamiƒôci pod nowƒÖ nazwƒÖ
    globals[checkpointName] = window.currentData;
    localStorage.setItem(GLOBAL_CHECKPOINTS_KEY, JSON.stringify(globals));

    // Ustawienie go jako aktywnego
    localStorage.setItem(CURRENT_ACTIVE_CHECKPOINT_KEY, checkpointName);
    
    // Od≈õwie≈ºenie listy rozwijanej
    initGlobalCheckpoints();
    document.getElementById('globalCheckpointSelect').value = checkpointName;

    alert(`Trwa≈Çy checkpoint '${checkpointName}' zapisany i ustawiony jako aktywny.`);
    document.getElementById("extractBtn").textContent = "Por√≥wnaj";
    
    // NOWA ZMIANA: Wyczyszczenie pola tekstowego
    document.getElementById("inputHTML").value = "";
}


// NOWA FUNKCJA: Usuwanie wybranego globalnego checkpointa
function deleteSelectedGlobalCheckpoint() {
    const select = document.getElementById('globalCheckpointSelect');
    const keyToDelete = select.value;

    if (!keyToDelete || keyToDelete === LOCAL_CHECKPOINT_KEY) {
        alert("Wybierz trwa≈Çy checkpoint z listy, kt√≥ry chcesz usunƒÖƒá.");
        return;
    }

    if (!confirm(`Czy na pewno chcesz usunƒÖƒá trwa≈Çy checkpoint: '${keyToDelete}'? Tego nie da siƒô cofnƒÖƒá!`)) {
        return;
    }

    const globals = JSON.parse(localStorage.getItem(GLOBAL_CHECKPOINTS_KEY) || "{}");
    
    if (globals[keyToDelete]) {
        delete globals[keyToDelete];
        localStorage.setItem(GLOBAL_CHECKPOINTS_KEY, JSON.stringify(globals));

        // Sprawdzenie, czy usuwany by≈Ç aktywnym
        const activeKey = getActiveCheckpointKey();
        if (activeKey === keyToDelete) {
            // Prze≈ÇƒÖcz na lokalny (domy≈õlny)
            localStorage.setItem(CURRENT_ACTIVE_CHECKPOINT_KEY, LOCAL_CHECKPOINT_KEY);
            document.getElementById("extractBtn").textContent = "Por√≥wnaj"; // Zachowanie logiki 'Por√≥wnaj'
        }
        
        // Od≈õwie≈ºenie listy rozwijanej
        initGlobalCheckpoints();
        alert(`Trwa≈Çy checkpoint '${keyToDelete}' zosta≈Ç usuniƒôty.`);
        
        // Je≈õli pole tekstowe nie jest puste, spr√≥buj od≈õwie≈ºyƒá por√≥wnanie
        if (document.getElementById("inputHTML").value.trim()) {
            extractMultiple();
        }
    } else {
        alert(`B≈ÇƒÖd: Checkpoint '${keyToDelete}' nie zosta≈Ç znaleziony.`);
    }
}


// ===== ALIASY (old -> new) (bez zmian) =====
function loadAliases() { return JSON.parse(localStorage.getItem("bkAliases") || "{}"); }
function saveAliases(aliases) { localStorage.setItem("bkAliases", JSON.stringify(aliases)); }

function getCanonicalNick(nick) {
  const aliases = loadAliases();
  let current = nick;
  let moved = true;
  while (moved) {
    moved = false;
    for (const [oldName, newName] of Object.entries(aliases)) {
      if (newName === current && oldName !== current) {
        current = oldName;
        moved = true;
        break;
      }
    }
  }
  return current;
}
// ===============================

function parseSingleProfile(html) {
  let nick = "Nieznany";
  const nickMatch = html.match(REGEX_NICK); // U≈ºycie sta≈Çego REGEX
  if (nickMatch) { nick = nickMatch[1].trim(); }

  let zakon = "";
  const zakonMatch = html.match(REGEX_ZAKON); // U≈ºycie sta≈Çego REGEX
  if (zakonMatch) { zakon = zakonMatch[1].trim(); }

  const total = {};
  for (let attr of attrKeys) {
    // U≈ºycie prekompilowanego REGEX
    const match = html.match(REGEX_BASE_ATTRS[attr]);
    total[attr] = match ? parseInt(match[1]) : 0;
  }

  const bonusyPkt = {};
  for (let attr of attrKeys) bonusyPkt[attr] = 0;

  // U≈ºycie sta≈Çego REGEX
  const itemTips = [...html.matchAll(REGEX_ITEM_TIPS)]; 
  for (const [, tipRaw] of itemTips) {
    const tip = tipRaw.replace(/\\\\/g, "\\").replace(/\\\"/g, '"').replace(/\\'/g, "'");
    if (/kopia/i.test(tip) || /Kopa/i.test(tip) || /≈Çamacz ≈Ça≈Ñcuchowy/i.test(tip) || /Powalacz rycerzy/i.test(tip) || /Pazur gryfa/i.test(tip) || /Szokopia/i.test(tip) || /Wysiod≈Çacz/i.test(tip) || /Stalowy szpic/i.test(tip) || /≈ªƒÖd≈Ço/i.test(tip) || /lanca/i.test(tip) || /rozp≈Çatacz tarcz/i.test(tip) || /Wiatro≈Çamacz/i.test(tip)) continue;
    
    // üî• OPYMALIZACJA: U≈ºycie prekompilowanego REGEX w pƒôtli bonus√≥w
    for (let attr of attrKeys) {
      const m = tip.match(REGEX_BASE_ATTRS[attr]); 
      if (m) bonusyPkt[attr] += parseInt(m[1]);
    }
  }

  let bonusProcSzczescie = 0;
  // U≈ºycie sta≈Çego REGEX
  const modifyLuckMatch = html.match(REGEX_MODIFY_LUCK);
  if (modifyLuckMatch) { bonusProcSzczescie = parseInt(modifyLuckMatch[1]) / 100; }

  const base = {};
  const bonusProcWPkt = {};
  const suma = {};

  for (let attr of attrKeys) {
    if (attr === "Szczƒô≈õcie") {
      // LOGIKA OBLICZANIA SZCZƒò≈öCIA POZOSTAJE BEZ ZMIAN!
      base[attr] = Math.ceil(total[attr] / (1 + bonusProcSzczescie)) - bonusyPkt[attr];
      bonusProcWPkt[attr] = Math.round((base[attr] + bonusyPkt[attr]) * bonusProcSzczescie);
      suma[attr] = base[attr] + bonusyPkt[attr] + bonusProcWPkt[attr];
    } else {
      base[attr] = total[attr] - bonusyPkt[attr];
      bonusProcWPkt[attr] = 0;
      suma[attr] = total[attr];
    }
  }

  const stats = {};
  for (let key in statKeys) {
    // üî• OPYMALIZACJA: U≈ºycie prekompilowanego REGEX
    const match = html.match(REGEX_STATS[key]);
    // POPRAWKA: Usuniƒôcie separator√≥w tysiƒôcy (kropek) przed parsowaniem na liczbƒô
    stats[statKeys[key]] = match ? parseInt(match[1].replace(/\./g, "")) : 0;
  }

  return { nick, zakon, base, suma, stats };
}

function formatDiff(diff, statName) {
  if (diff === null) return "";
  
  // NOWA LOGIKA DLA KONDYCJI (Œî) - Zwracamy czysty tekst, je≈õli > 0, bo kom√≥rka <td> bƒôdzie stylowana
  if (statName === "Kondycja" && diff > 0) {
    return diff; 
  }
  
  // obs≈Çuga kolumny "Staty (Œî)" i "≈ÅƒÖcznie Atrybut√≥w (Œî)" w podsumowaniu
  if (statName === "Staty" || statName === "≈ÅƒÖcznie Atrybut√≥w") {
    if (diff === 0) return `<span class="zero-diff">0</span>`; 
    return `<span style="color:#ff00ff;font-weight:bold;">${diff}</span>`; // R√≥≈ºowy/fioletowy kolor
  }

  if (diff === 0) return `<span class="zero-diff">0</span>`;

  if (statName === "≈Åup stracony" || statName === "Pora≈ºki") {
    return diff > 0 ? `<span class="diff-neg">${diff}</span>` : `<span class="diff-pos">${diff}</span>`;
  }

  if (statName === "Remisy") {
    return diff > 0 ? `<span class="draws-diff">${diff}</span>` : `<span class="diff-neg">${diff}</span>`;
  }
  
  // Nowa logika dla 'Wygranych turniej√≥w'
  if (statName === "Wygranych turniej√≥w") {
      return diff > 0 ? `<span class="diff-pos">${diff}</span>` : `<span class="diff-neg">${diff}</span>`;
  }

  return diff > 0 ? `<span class="diff-pos">${diff}</span>` : `<span class="diff-neg">${diff}</span>`;
}

// === WERSJA Z POMARA≈ÉCZOWYMI SUMAMI I BEZ ZNAKU PLUS ===
function showPlayerSummaryPopup(nick) {
    const canonicalNick = getCanonicalNick(nick);
    const player = window.lastResults.find(p => getCanonicalNick(p.nick) === canonicalNick);
    
    if (!player) {
        alert(`Brak danych dla gracza: ${nick}`);
        return;
    }

    const modal = document.getElementById('playerSummaryModal');
    const content = document.getElementById('summaryDetails');
    const activeCheckpointKey = getActiveCheckpointKey();
    const checkpoint = loadCheckpointData(activeCheckpointKey);
    const prevStats = checkpoint.stats[canonicalNick] || {};
    const prevBase = checkpoint.base[canonicalNick] || {};

    // Pomocnicza funkcja: Delta bez plusa, z kolorowaniem inline
    const getColoredDelta = (diff, type = 'normal') => {
        if (diff === 0) return `<span style="color: #2196f3;">0</span>`;
        
        let color = '#32ff32'; // Zielony dla wzrostu
        if (type === 'negative_is_bad' && diff > 0) color = '#f44336'; // Czerwony dla wzrostu strat
        if (type === 'negative_is_bad' && diff < 0) color = '#32ff32'; // Zielony dla spadku strat
        if (type === 'normal' && diff < 0) color = '#f44336'; // Czerwony dla spadku statystyk
        
        return `<span style="color: ${color}; font-weight: bold;">${diff}</span>`; // Brak znaku plus
    };

    let html = `
        <p><strong>Nick:</strong> ${player.nick}</p>
        <p><strong>Zakon:</strong> ${player.zakon || 'Brak'}</p>
        <p><strong>Por√≥wnanie:</strong> Œî od checkpointa (klucz: ${activeCheckpointKey})</p>
        
        <h3>üìä Przyrost Atrybut√≥w (Œî)</h3>
        <div class="summary-grid">
    `;

    let totalRaised = 0;
    
    for (const attr of attrKeys) {
        const val = player.base[attr] ?? 0;
        const basePrev = prevBase[attr] ?? 0;
        const diff = val - basePrev;
        totalRaised += diff;

        let diffHtml;
        if (attr === 'Kondycja' && diff > 0) {
            diffHtml = `<span style="background-color: #e53935; color: white; font-weight: bold; padding: 2px 4px; border-radius: 3px;">${diff}</span>`;
        } else {
            diffHtml = getColoredDelta(diff);
        }

        html += `
            <div class="summary-grid-item">
                <span>${attr}:</span>
                <span>${val} (Œî ${diffHtml})</span>
            </div>
        `;
    }

    // ≈ÅƒÖcznie Podniesione Atrybuty (Zmienione na pomara≈Ñczowy/≈º√≥≈Çty fbbc04)
    html += `
            <div class="summary-grid-item" style="grid-column: 1 / span 2; border-top: 1px solid #333; margin-top: 10px;">
                <span style="color: #fbbc04;">≈ÅƒÖcznie Podniesione Atrybuty:</span>
                <span style="color: #fbbc04; font-weight: bold;">${totalRaised}</span>
            </div>
        </div>
    `;

// 2. Statystyki Walk i ≈Åupu (NOWA KOLEJNO≈öƒÜ)
    html += `
        <h3>‚öîÔ∏è Statystyki Walk i ≈Åupu (Œî)</h3>
        <div class="summary-grid">
    `;
    
    // Definiujemy nowƒÖ kolejno≈õƒá statystyk w parach
    const orderedStats = [
        "Poziom", "Wygranych turniej√≥w",
        "≈Åup zdobyty", "≈Åup stracony",
        "Zwyciƒôstwa", "Pora≈ºki",
        "Remisy"
    ];

    let totalFights = 0;
    
    for (const statName of orderedStats) {
        const val = player.stats[statName] ?? 0;
        const statPrev = prevStats[statName] ?? 0;
        const diff = val - statPrev;
        
        const isNegativeStat = (statName === "≈Åup stracony" || statName === "Pora≈ºki");
        const diffHtml = getColoredDelta(diff, isNegativeStat ? 'negative_is_bad' : 'normal');

        if (["Zwyciƒôstwa", "Remisy", "Pora≈ºki"].includes(statName)) {
            totalFights += diff;
        }

        // Je≈õli to Remisy, zajmujƒÖ one ca≈ÇƒÖ szeroko≈õƒá lub sƒÖ wyr√≥wnane do lewej (zale≈ºnie od grid)
        const gridStyle = statName === "Remisy" ? 'style="grid-column: 1 / span 1;"' : '';

        html += `
            <div class="summary-grid-item" ${gridStyle}>
                <span>${statName}:</span>
                <span>${val} (Œî ${diffHtml})</span>
            </div>
        `;
    }
    
    // ≈ÅƒÖczna Liczba Walk
    html += `
        <div class="summary-grid-item" style="grid-column: 1 / span 2; border-top: 1px solid #333; margin-top: 10px;">
            <span style="color: #fbbc04;">≈ÅƒÖczna Liczba Walk:</span>
            <span style="color: #fbbc04; font-weight: bold;">${totalFights}</span>
        </div>
        </div>
    `;

    const deltaLupZdobyty = (player.stats["≈Åup zdobyty"] ?? 0) - (prevStats["≈Åup zdobyty"] ?? 0);
    const deltaLupStracony = (player.stats["≈Åup stracony"] ?? 0) - (prevStats["≈Åup stracony"] ?? 0);
    const deltaZwyciestwa = (player.stats["Zwyciƒôstwa"] ?? 0) - (prevStats["Zwyciƒôstwa"] ?? 0);
    const deltaRemisy = (player.stats["Remisy"] ?? 0) - (prevStats["Remisy"] ?? 0);
    const deltaPorazki = (player.stats["Pora≈ºki"] ?? 0) - (prevStats["Pora≈ºki"] ?? 0);

    const fightsForGain = deltaZwyciestwa + deltaRemisy;
    const avgGain = fightsForGain > 0 ? (deltaLupZdobyty / fightsForGain).toFixed(2) : "0";
    const avgLoss = deltaPorazki > 0 ? (deltaLupStracony / deltaPorazki).toFixed(2) : "0";
    const percentLost = deltaLupZdobyty > 0 ? ((deltaLupStracony / deltaLupZdobyty) * 100).toFixed(1) + "%" : "0%";

    html += `
        <h3>‚ú® Dodatkowe Wska≈∫niki</h3>
        <div class="summary-grid">
            <div class="summary-grid-item">
                <span>≈öredni Zysk (za walkƒô):</span>
                <span style="color: #32ff32; font-weight: bold;">${avgGain}</span>
            </div>
            <div class="summary-grid-item">
                <span>≈örednia Strata (za pora≈ºkƒô):</span>
                <span style="color: #f44336; font-weight: bold;">${avgLoss}</span>
            </div>
            <div class="summary-grid-item">
                <span>% Straconego ≈Åupu:</span>
                <span style="color: #2196f3; font-weight: bold;">${percentLost}</span>
            </div>
        </div>
    `;

    content.innerHTML = html;
    modal.style.display = 'flex';
}

function extractMultipleAndClear() { extractMultiple(); document.getElementById("inputHTML").value = ""; }
function saveCheckpointAndClear() { saveCheckpoint(); document.getElementById("inputHTML").value = ""; }

let attrsHidden = false; // stan ukrycia atrybut√≥w
function toggleAttributes() {
  const table = document.getElementById("dataTable");
  if (!table) return;

  // kolumny: #=0, Nick=1, Zakon=2, potem atrybuty (po 2 kolumny: warto≈õƒá + ‚áÖ), oraz "Staty (Œî)" (np. indeks 15)
  const colsToToggle = [3,4,5,6,7,8,9,10,11,12,13,14,15];

  colsToToggle.forEach(idx => {
    for (const row of table.rows) {
      if (row.cells[idx]) {
        row.cells[idx].style.display = attrsHidden ? "" : "none";
      }
    }
  });

  attrsHidden = !attrsHidden;
  document.getElementById("toggleAttrBtn").textContent = attrsHidden ? "Poka≈º atrybuty" : "Ukryj atrybuty";
}

let tournamentsHidden = false; // NOWA flaga stanu ukrycia turniej√≥w
function toggleTournaments() {
  const table = document.getElementById("dataTable");
  if (!table) return;

  // Kolumny: Wygranych turniej√≥w (indeks 21) oraz ‚áÖ (indeks 22)
  // W oryginalnym kodzie kolumny turniej√≥w to indeksy 21 i 22
  // Zliczanie indeks√≥w: Poziom (16,17), ≈Åup zd. (18,19), ≈Åup str. (20), Turnieje (21, 22), Zwy. (23), Rem. (24), Por. (25)
  const turniejIndex = 21; 
  const colsToToggle = [turniejIndex, turniejIndex + 1];

  colsToToggle.forEach(idx => {
    for (const row of table.rows) {
      // Wiersz nag≈Ç√≥wk√≥w (0) ma o jednƒÖ kom√≥rkƒô mniej na koniec (brakuje kolumny Œî, kt√≥ra jest w Zwyciƒôstwa)
      // W wierszu nag≈Ç√≥wk√≥w, turniej to indeks 20 i 21
      if (row.cells[idx]) row.cells[idx].style.display = tournamentsHidden ? "" : "none";
    }
  });

  tournamentsHidden = !tournamentsHidden;
  document.getElementById("toggleTournamentsBtn").textContent = tournamentsHidden 
    ? "Poka≈º turnieje" 
    : "Ukryj turnieje";
}


let statsHidden = false; // stan ukrycia kolumn poziom/≈Çupy/walki
function toggleStatsColumns() {
  const table = document.getElementById("dataTable");
  if (!table) return;

  // kolumny do ukrycia (bez turniej√≥w):
  // Poziom (16, 17), ≈Åup zdobyty (18, 19), ≈Åup stracony (20)
  // Zwyciƒôstwa (23), Remisy (24), Pora≈ºki (25)
  const colsToToggle = [16, 17, 18, 19, 20, 23, 24, 25];

  colsToToggle.forEach(idx => {
    for (const row of table.rows) {
      if (row.cells[idx]) {
        row.cells[idx].style.display = statsHidden ? "" : "none";
      }
    }
  });

  statsHidden = !statsHidden;
  document.getElementById("toggleStatsBtn").textContent = statsHidden 
    ? "Poka≈º poziom, ≈Çupy i walki" 
    : "Ukryj poziom, ≈Çupy i walki";
}


function guildClassFor(zakon) {
  if (!zakon) return 'guild-default';
  const z = zakon.trim();
  if (z === '[-U-]' || z === '[[PD]]') return 'guild-u';
  if (z === '[IMP]' || z === '[Temp]') return 'guild-imp';
  if (z === '[F-FUN]') return 'guild-fun';
  return 'guild-default';
}

function extractMultiple() {
  const allHTML = document.getElementById("inputHTML").value;
  if (!allHTML.trim()) { alert("Wklej kod profili do pola tekstowego."); return; }
  
  // ≈Åadowanie aktywnego checkpointa (lokalnego lub globalnego)
  const activeCheckpointKey = getActiveCheckpointKey();
  const checkpoint = loadCheckpointData(activeCheckpointKey);

  const checkpointBase = checkpoint.base || {};
  const checkpointStats = checkpoint.stats || {};

  const profilesRaw = allHTML.split(/(?=<!DOCTYPE html PUBLIC)/i);
  const allResultsRaw = []; // Tymczasowa tablica na wszystkie sparsowane profile
  for (const profRaw of profilesRaw) {
    if (!profRaw.trim()) continue;
    try { const parsed = parseSingleProfile(profRaw); allResultsRaw.push(parsed); } catch {}
  }

  // >>> DEDUPLIKACJA GRACZY <<<
  const uniqueResults = {};
  for (const player of allResultsRaw) {
    const canonical = getCanonicalNick(player.nick);
    // U≈ºywamy canonical jako klucza, by uniknƒÖƒá duplikat√≥w tego samego gracza.
    if (!uniqueResults[canonical]) {
        uniqueResults[canonical] = player;
    }
  }
  const allResults = Object.values(uniqueResults); // Ostateczna, unikalna tablica
  // >>> KONIEC POPRAWKI <<<

  if (allResults.length === 0) { 
    document.getElementById("result").innerHTML = "<p>Nie znaleziono ≈ºadnych poprawnych profili.</p>"; 
    return; 
  }

  const baseHeaders = attrKeys.map(a => a);
  const statsHeaders = Object.values(statKeys);
  const diffOnlyStats = ["≈Åup stracony", "Zwyciƒôstwa", "Remisy", "Pora≈ºki"];

  // ===== TWORZENIE NAG≈Å√ìWK√ìW =====
  let html = `<table id="dataTable"><thead><tr><th>#</th><th>Nick</th><th>Zakon</th>`;

  // kolumny atrybut√≥w
  for (const header of baseHeaders) {
    const disp = displayNames[header] || header;
    html += `<th>${disp}</th><th>&#8645;</th>`;
  }

  // nowa kolumna suma podniesionych stat√≥w
  html += `<th>Staty (Œî)</th>`;

  // kolumny pozosta≈Çych statystyk
  for (const stat of statsHeaders) {
    const disp = displayNames[stat] || stat;
    if (diffOnlyStats.includes(stat)) {
      html += `<th>${disp} (Œî)</th>`;
    } else {
      html += `<th>${disp}</th><th>&#8645;</th>`;
    }
  }

  // ===== NOWE KOLUMNY: ≈öredni zysk / ≈örednia strata / % straconego ≈Çupu =====
  html += `<th style="display:none">≈öredni zysk</th>`;
  html += `<th style="display:none">≈örednia strata</th>`;
  html += `<th style="display:none">% straconego ≈Çupu</th>`;

  html += `</tr></thead><tbody>`;

  // ===== WYPE≈ÅNIANIE WIERSZY =====
  let rowIndex = 1;
  for (const player of allResults) {
    const canonical = getCanonicalNick(player.nick);
    const prevStats = checkpointStats[canonical] || {};
    const prevBase = checkpointBase[canonical] || {};

// Obliczamy ≈õredni zysk: przyrost ≈Åupu / (Zwyciƒôstwa + Remisy)
const deltaLupZdobyty = (player.stats["≈Åup zdobyty"] ?? 0) - (prevStats["≈Åup zdobyty"] ?? 0);
const deltaZwyciestwa = (player.stats["Zwyciƒôstwa"] ?? 0) - (prevStats["Zwyciƒôstwa"] ?? 0);
const deltaRemisy = (player.stats["Remisy"] ?? 0) - (prevStats["Remisy"] ?? 0);

const fights = (deltaZwyciestwa + deltaRemisy);
const avgGain = fights ? (deltaLupZdobyty / fights).toFixed(2) : "0";


    // ≈õrednia strata
    const deltaLupStracony = (player.stats["≈Åup stracony"] ?? 0) - (prevStats["≈Åup stracony"] ?? 0);
    const deltaPorazki = (player.stats["Pora≈ºki"] ?? 0) - (prevStats["Pora≈ºki"] ?? 0);
    const avgLoss = deltaPorazki ? (deltaLupStracony / deltaPorazki).toFixed(2) : "0";

    // % straconego ≈Çupu
    const percentLost = deltaLupZdobyty ? ((deltaLupStracony / deltaLupZdobyty) * 100).toFixed(1) + "%" : "0%";

    html += `<tr><td>${rowIndex++}</td><td>${player.nick}</td><td>${player.zakon}</td>`;

    // kolumny atrybut√≥w + przyrosty (ZMODYFIKOWANA PƒòTLA DLA KONDYCJI)
    for (const attr of baseHeaders) {
      const val = player.base[attr] ?? 0;
      const basePrev = prevBase[attr];
      const diff = basePrev !== undefined ? val - basePrev : null;
      
      let diffCellStyles = '';
      // Je≈õli jest to r√≥≈ºnica Kondycji i Kondycja wzros≈Ça (Œî > 0)
      if (attr === 'Kondycja' && diff > 0) {
        // Czerwone t≈Ço, bia≈Çy tekst, pogrubienie
        diffCellStyles = ' style="background-color: #e53935; color: white; font-weight: bold;"';
      } 

      html += `<td>${val}</td><td${diffCellStyles}>${formatDiff(diff, attr)}</td>`;
    }
    // KONIEC ZMODYFIKOWANEJ PƒòTLI

    // suma podniesionych stat√≥w
    let totalRaised = 0;
    for (const attr of baseHeaders) {
      const basePrev = prevBase[attr];
      const diff = basePrev !== undefined ? player.base[attr] - basePrev : 0;
      totalRaised += diff;
    }
    html += `<td>${formatDiff(totalRaised, 'Staty')}</td>`;

    // kolumny statystyk
    for (const stat of statsHeaders) {
      const val = player.stats[stat] ?? 0;
      const statPrev = prevStats[stat];
      const rawDiff = statPrev !== undefined ? val - statPrev : null;

      if (diffOnlyStats.includes(stat)) {
        const diff = (rawDiff === null) ? 0 : rawDiff;
        html += `<td>${formatDiff(diff, stat)}</td>`;
      } else {
        html += `<td>${val}</td><td>${formatDiff(rawDiff, stat)}</td>`;
      }
    }

    // ===== NOWE KOLUMY =====
    html += `<td style="display:none">${avgGain}</td>`;
    html += `<td style="display:none">${avgLoss}</td>`;
    html += `<td style="display:none">${percentLost}</td>`;

    html += `</tr>`;
  }

  html += `</tbody></table>`;

  document.getElementById("result").innerHTML = html;

  // zapis bie≈ºƒÖcych danych
  window.currentData = { base: {}, stats: {} };
  window.lastResults = allResults; // <<< Zapis ca≈Çego zbioru dla podsumowania (ju≈º unikalnego)
  for (const p of allResults) {
    const canonical = getCanonicalNick(p.nick);
    window.currentData.base[canonical] = p.base;
    window.currentData.stats[canonical] = p.stats;
  }

  document.getElementById("extractBtn").textContent = "Por√≥wnaj";
  addTableSorting();
  addRowHighlighting();

  const { missing, extra } = detectUnmatchedPlayers(allResults, checkpoint);
  showAliasManager(missing, extra);
}




function detectUnmatchedPlayers(newPlayers, checkpoint) {
  const checkpointNicks = Object.keys(checkpoint.base || {});
  const canonicalNewKeys = newPlayers.map(p => getCanonicalNick(p.nick));
  const missing = checkpointNicks.filter(n => !canonicalNewKeys.includes(n));
  const extra = newPlayers.filter(p => !checkpointNicks.includes(getCanonicalNick(p.nick))).map(p => p.nick);
  const extraUnique = [...new Set(extra)];
  return { missing, extra: extraUnique };
}

function showAliasManager(missing, extra) {
  const box = document.getElementById("aliasManager");
  if (!missing.length && !extra.length) { box.innerHTML = `<h3>Brak rozjechanych nick√≥w</h3>`; return; }
  if (!missing.length || !extra.length) { box.innerHTML = `<h3>Dopasuj zmienione nicki:</h3><div>Brakuje par do dopasowania.</div>`; return; }

  let html = `<h3>Dopasuj zmienione nicki</h3>`;
  html += `<table><tr><th>Stary nick (z checkpointu)</th><th>Nowy nick (z obecnych danych)</th></tr>`;
  for (let oldNick of missing) {
    html += `<tr>
      <td>${oldNick}</td>
      <td>
        <select data-old="${oldNick}" onchange="saveSingleAlias(this)">
          <option value="">-- wybierz --</option>`;
    for (let newNick of extra) { html += `<option value="${newNick}">${newNick}</option>`; }
    html += `</select>
      </td>
    </tr>`;
  }
  html += `</table>`;
  box.innerHTML = html;
}

function saveSingleAlias(sel) {
  const oldNick = sel.dataset.old;
  const newNick = sel.value;
  if (!newNick) return;
  const aliases = loadAliases();
  aliases[oldNick] = newNick;
  saveAliases(aliases);
  extractMultiple();
}

function addRowHighlighting() {
  const table = document.getElementById("dataTable");
  if (!table) return;
  const rows = table.querySelectorAll("tbody tr");

  rows.forEach(row => {
    const nickCell = row.cells[1];
    if (!nickCell) return;

    nickCell.style.cursor = "pointer";
    
    // --- 1. Pojedyncze klikniƒôcie (Pod≈õwietlanie wiersza) ---
    nickCell.addEventListener("click", () => {
      // Przywr√≥ƒá wszystkie wiersze do normalnego stanu
      rows.forEach(r => {
        for (const cell of r.cells) {
          cell.style.color = "";       
          cell.style.fontWeight = "";  
          const diffIndex = 8; // Kondycja Œî
          if (r.cells[diffIndex] && r.cells[diffIndex].style.backgroundColor !== "rgb(229, 57, 53)") {
             r.cells[diffIndex].style.backgroundColor = "";
          }
        }
      });

      // Pod≈õwietl klikniƒôty wiersz
      for (const cell of row.cells) {
        cell.style.color = "#fbbc04";
        cell.style.fontWeight = "bold";
        const diffIndex = 8;
        if (cell.cellIndex === diffIndex && cell.style.backgroundColor === "rgb(229, 57, 53)") {
             cell.style.color = "white";
        }
      }
    });

    // --- 2. PODW√ìJNE KLIKNIƒòCIE (Wywo≈Çuje szczeg√≥≈Çowe okno) ---
    nickCell.addEventListener("dblclick", (e) => {
        e.preventDefault(); // Blokuje domy≈õlne zaznaczanie tekstu
        showPlayerSummaryPopup(nickCell.textContent.trim());
    });
  });
}


function saveCheckpoint() {
  if (!window.currentData) { alert("Brak danych do zapisu. Najpierw wyciƒÖgnij dane."); return; }
  localStorage.setItem(LOCAL_CHECKPOINT_KEY, JSON.stringify(window.currentData));
  alert("Checkpoint lokalny zapisany!");
  
  // Prze≈ÇƒÖczenie na lokalny, je≈õli by≈Ç aktywny globalny
  const activeKey = getActiveCheckpointKey();
  if (activeKey !== LOCAL_CHECKPOINT_KEY) {
    loadGlobalCheckpoint(''); // Wyczy≈õƒá aktywny, prze≈ÇƒÖcz na lokalny
  }
  
  document.getElementById("extractBtn").textContent = "Por√≥wnaj";
}

// ZMODYFIKOWANA FUNKCJA RESETU
function resetCheckpoint() {
  localStorage.removeItem(LOCAL_CHECKPOINT_KEY);
  localStorage.removeItem("bkAliases");
  localStorage.removeItem(CURRENT_ACTIVE_CHECKPOINT_KEY); // Resetowanie wyboru aktywnego checkpointa
  
  // USUNIƒòTO: localStorage.removeItem(GLOBAL_CHECKPOINTS_KEY); - Celowo pozostawia trwa≈Çe checkpointy
  
  document.getElementById("inputHTML").value = "";
  document.getElementById("result").innerHTML = "";
  document.getElementById("aliasManager").innerHTML = "";
  
  // Od≈õwie≈ºenie listy rozwijanej
  initGlobalCheckpoints();
  
  alert("Checkpoint lokalny oraz aliasy zresetowane! Trwa≈Çe checkpointy (Globalne) zosta≈Çy zachowane.");
  document.getElementById("extractBtn").textContent = "WyciƒÖgnij dane";
}

function addTableSorting() {
  const table = document.getElementById("dataTable");
  if (!table) return;

  const headers = table.querySelectorAll("th");
  headers.forEach((header, index) => {
    if (index === 0) return; // kolumna # nie sortuje

    header.addEventListener("click", () => {
      const tbody = table.tBodies[0];
      const rows = Array.from(tbody.querySelectorAll("tr"));
      const asc = !header.classList.contains("asc");

      // helper: parsuje liczbƒô z tekstu (usuwa wszystko opr√≥cz cyfr, minus, przecinka, kropki)
      const parseNumberFrom = (text) => {
        if (!text) return NaN;
        const cleaned = text.replace(/\+/g, "").replace("%", "").replace(/[^\d\-,.]/g, "").replace(",", ".");
        if (cleaned === "" || cleaned === "-" ) return NaN;
        return parseFloat(cleaned);
      };

      // sortowanie
      rows.sort((a, b) => {
        const Araw = (a.cells[index] && a.cells[index].textContent) ? a.cells[index].textContent.trim() : "";
        const Braw = (b.cells[index] && b.cells[index].textContent) ? b.cells[index].textContent.trim() : "";

        const numA = parseNumberFrom(Araw);
        const numB = parseNumberFrom(Braw);
        const isNumeric = !isNaN(numA) && !isNaN(numB);

        if (isNumeric) {
          return asc ? numA - numB : numB - numA;
        } else {
          // por√≥wnanie tekstowe, case-insensitive
          return asc ? Araw.localeCompare(Braw, undefined, { sensitivity: "base" }) 
                     : Braw.localeCompare(Araw, undefined, { sensitivity: "base" });
        }
      });

      // aktualizacja klas sortowania (asc/desc)
      headers.forEach(h => h.classList.remove("asc", "desc"));
      header.classList.add(asc ? "asc" : "desc");

      // wstawienie wierszy w nowej kolejno≈õci
      rows.forEach(row => tbody.appendChild(row));

      // aktualizacja numeru w kolumnie #
      updateRowNumbers(table);

      // przywr√≥ƒá/od≈õwie≈º highlight klikniƒôƒá w wierszach
      addRowHighlighting();

      // indeksy ostatnich 3 kolumn (dynamicznie)
      const totalCols = table.rows[0].cells.length;
      const colGain = totalCols - 3;   // ≈öredni zysk
      const colLoss = totalCols - 2;   // ≈örednia strata
      const colPercent = totalCols - 1; // % straconego ≈Çupu

      // PRZYWR√ìƒÜ domy≈õlny wyglƒÖd dla kolumn gain/loss (bia≈Çy tekst, brak t≈Ça)
      rows.forEach(row => {
        if (row.cells[colGain]) { row.cells[colGain].style.color = "#ffffff"; row.cells[colGain].style.backgroundColor = "transparent"; }
        if (row.cells[colLoss]) { row.cells[colLoss].style.color = "#ffffff"; row.cells[colLoss].style.backgroundColor = "transparent"; }
      });

      // tylko je≈õli sortujemy po kolumnie gain/loss ‚Äî poka≈º gradient TEJ kolumny
      if (index === colGain || index === colLoss) {
        colorExtraColumn(table, index);
      }

      // zastosuj sp√≥jne kolory dla ostatniej kolumny (%) zawsze
      applyPercentColors(table);
    });
  });
}


// Zastosowanie sp√≥jnych kolor√≥w dla ostatniej kolumny (%)
function applyPercentColors(table) {
  if (!table) return;
  const totalCols = table.rows[0].cells.length;
  const colPercent = totalCols - 1;
  const rows = Array.from(table.tBodies[0].rows);

  const GREEN = "#34a853";   // zielony
  const YELLOW = "#fbbc04";  // ≈º√≥≈Çty
  const RED = "#ea4335";     // czerwony

  rows.forEach(row => {
    const cell = row.cells[colPercent];
    if (!cell) return;

    const raw = (cell.textContent || "").replace("%", "").replace(",", ".").trim();
    const val = parseFloat(raw);

    if (isNaN(val)) {
      cell.style.backgroundColor = "";
      cell.style.color = "";
      return;
    }

    if (val <= 3.0) {
      cell.style.backgroundColor = GREEN;
      cell.style.color = "#ffffff";
    } else if (val > 3.0 && val <= 10.0) {
      cell.style.backgroundColor = YELLOW;
      cell.style.color = "#121212";
    } else { // > 10.0
      cell.style.backgroundColor = RED;
      cell.style.color = "#ffffff";
    }

    cell.style.transition = "background-color .25s ease, color .25s ease";
  });
}


// funkcja kolorowania gradientem tylko jednej kolumny
function colorExtraColumn(table, colIndex) {
  const rows = Array.from(table.tBodies[0].querySelectorAll("tr"));
  let min = Infinity, max = -Infinity;

  // znajd≈∫ min/max w kolumnie
  rows.forEach(row => {
    const val = parseFloat(row.cells[colIndex].innerText.replace("%","").replace(",",".") || 0);
    if(val < min) min = val;
    if(val > max) max = val;
  });

  function interpolateColor(value, min, max, reverse=false) {
    let ratio = (value - min) / ((max - min) || 1);
    if (reverse) ratio = 1 - ratio;

    let r, g, b = 0;
    if (ratio < 0.5) {
      const localRatio = ratio / 0.5;
      r = 255;
      g = Math.round(255 * localRatio);
    } else {
      const localRatio = (ratio - 0.5) / 0.5;
      r = Math.round(255 * (1 - localRatio));
      g = 255;
    }
    return `rgb(${r},${g},${b})`;
  }

  const reverse = (colIndex === table.rows[0].cells.length - 2); // ≈örednia strata odwr√≥cony gradient
  rows.forEach(row => {
    const val = parseFloat(row.cells[colIndex].innerText.replace("%","").replace(",",".") || 0);
    row.cells[colIndex].style.color = interpolateColor(val, min, max, reverse);
  });
}

function updateRowNumbers(table) {
  const rows = table.tBodies[0].querySelectorAll("tr");
  let num = 1;
  rows.forEach(row => {
    row.cells[0].textContent = num++;
  });
}


function sortTableByColumn(table, columnIndex) {
  const tbody = table.tBodies[0];
  const rows = Array.from(tbody.querySelectorAll("tr"));
  const isNumeric = !isNaN(rows[0].cells[columnIndex].innerText.trim().replace(",", "."));
  const currentSort = table.dataset.sortColumn == columnIndex ? table.dataset.sortOrder : null;
  const newSortOrder = currentSort === "asc" ? "desc" : "asc";

  rows.sort((a, b) => {
    let aText = a.cells[columnIndex].innerText.trim();
    let bText = b.cells[columnIndex].innerText.trim();

    if (isNumeric) {
      // usu≈Ñ % je≈õli jest
      aText = parseFloat(aText.replace("%", "").replace(",", ".")) || 0;
      bText = parseFloat(bText.replace("%", "").replace(",", ".")) || 0;
    }

    if (aText > bText) return newSortOrder === "asc" ? 1 : -1;
    if (aText < bText) return newSortOrder === "asc" ? -1 : 1;
    return 0;
  });

  rows.forEach(row => tbody.appendChild(row));
  table.dataset.sortColumn = columnIndex;
  table.dataset.sortOrder = newSortOrder;

  addRowHighlighting();

// ---- dodanie kolorystyki gradientowej ----
const rowsArray = Array.from(tbody.querySelectorAll("tr"));
const colGainIndex = table.rows[0].cells.length - 3; // ≈öredni zysk
const colLossIndex = table.rows[0].cells.length - 2; // ≈örednia strata

// znajd≈∫ min/max dla ka≈ºdej kolumny
let minGain = Infinity, maxGain = -Infinity;
let minLoss = Infinity, maxLoss = -Infinity;

rowsArray.forEach(row => {
  const gain = parseFloat(row.cells[colGainIndex].innerText.replace("%","").replace(",",".")||0);
  const loss = parseFloat(row.cells[colLossIndex].innerText.replace("%","").replace(",",".")||0);
  if(gain < minGain) minGain = gain;
  if(gain > maxGain) maxGain = gain;
  if(loss < minLoss) minLoss = loss;
  if(loss > maxLoss) maxLoss = loss;
});

// ustaw kolor t≈Ça
rowsArray.forEach(row => {
  const gain = parseFloat(row.cells[colGainIndex].innerText.replace("%","").replace(",",".")||0);
  const loss = parseFloat(row.cells[colLossIndex].innerText.replace("%","").replace(",",".")||0);

  // ≈öredni zysk: je≈õli 0 ‚Üí niebieski, inaczej gradient zielono-czerwony
  if (gain === 0) {
      row.cells[colGainIndex].style.backgroundColor = "#2196f3"; // niebieskie t≈Ço
  } else {
      let ratioGain = (gain - minGain)/(maxGain - minGain || 1); // 0..1
      let gainColor = `rgb(${Math.floor(255*(1-ratioGain))}, ${Math.floor(255*ratioGain)}, 0)`; 
      row.cells[colGainIndex].style.backgroundColor = gainColor;
  }

  // ≈örednia strata: gradient nadal normalnie
  let ratioLoss = (loss - minLoss)/(maxLoss - minLoss || 1); // 0..1
  let lossColor = `rgb(${Math.floor(255*ratioLoss)}, ${Math.floor(255*(1-ratioLoss))}, 0)`;
  row.cells[colLossIndex].style.backgroundColor = lossColor;
});
}

document.addEventListener("dragover", e => { e.preventDefault(); e.dataTransfer.dropEffect = "copy"; });
document.addEventListener("drop", e => {
  e.preventDefault();
  const file = e.dataTransfer.files[0];
  if (file && file.type === "text/plain") {
    const reader = new FileReader();
    reader.onload = event => { document.getElementById("inputHTML").value = event.target.result; extractMultiple(); };
    reader.readAsText(file);
  }
});

function copyChangedRows() {
  const table = document.getElementById("dataTable");
  if (!table) return;

  let textToCopy = "";
  const rows = table.tBodies[0].rows;

  for (const row of rows) {
    const statCell = row.cells[15]; // kolumna "Staty (Œî)"
    if (!statCell) continue;

    const cellText = statCell.innerText.replace(/\D/g,''); // zostawiamy tylko cyfry
    if (cellText && parseInt(cellText) > 0) {
      const rowText = Array.from(row.cells).map(c => c.innerText.trim()).join("\t");
      textToCopy += rowText + "\n";
    }
  }

  if (!textToCopy) {
    alert("Brak wierszy ze zmianami do skopiowania.");
    return;
  }

  navigator.clipboard.writeText(textToCopy).then(() => {
    alert("Skopiowano wiersze ze zmianami!");
  });
}

let extraHidden = true; // domy≈õlnie ukryte

function toggleExtraColumns() {
  const table = document.getElementById("dataTable");
  if (!table) return;

  // Indeksy 3 nowych kolumn po prawej stronie: zawsze ostatnie trzy
  const totalCols = table.rows[0].cells.length;
  const colsToToggle = [totalCols-3, totalCols-2, totalCols-1];

  colsToToggle.forEach(idx => {
    for (const row of table.rows) {
      if (row.cells[idx]) {
        row.cells[idx].style.display = extraHidden ? "" : "none";
      }
    }
  });

  extraHidden = !extraHidden;
  document.getElementById("toggleExtraBtn").textContent = extraHidden ? "Wiƒôcej danych" : "Ukryj dodatkowe";

  // je≈õli pokazujemy kolumny, ustawiamy gradient kolor√≥w
  if (!extraHidden) colorExtraColumns(table);
}

function colorExtraColumns(table) {
  const tbody = table.tBodies[0];
  const rowsArray = Array.from(tbody.querySelectorAll("tr"));
  const colGainIndex = table.rows[0].cells.length - 3; // ≈öredni zysk
  const colLossIndex = table.rows[0].cells.length - 2; // ≈örednia strata
  const colPercentIndex = table.rows[0].cells.length - 1; // % straconego ≈Çupu

  let minGain = Infinity, maxGain = -Infinity;
  let minLoss = Infinity, maxLoss = -Infinity;

  // Helper do formatowania liczb
  function formatNumber(value, decimals = 1, addPercent = false) {
    if (isNaN(value)) return "";
    let formatted = parseFloat(value).toFixed(decimals);
    if (addPercent) formatted += "%";
    return formatted;
  }

  // Obliczenie min/max dla kolorowania gradientowego
  rowsArray.forEach(row => {
    const gainCell = row.cells[colGainIndex];
    const lossCell = row.cells[colLossIndex];
    
    // Dodano sprawdzenie istnienia kom√≥rki
    if (gainCell && lossCell) {
        const gain = parseFloat(gainCell.innerText.replace("%","").replace(",",".")) || 0;
        const loss = parseFloat(lossCell.innerText.replace("%","").replace(",",".")) || 0;
        if (!isNaN(gain)) {
          if(gain < minGain) minGain = gain;
          if(gain > maxGain) maxGain = gain;
        }
        if (!isNaN(loss)) {
          if(loss < minLoss) minLoss = loss;
          if(loss > maxLoss) maxLoss = loss;
        }
    }
  });

  function interpolateColor(value, min, max, reverse=false) {
    let ratio = (value - min) / ((max - min) || 1);
    if (reverse) ratio = 1 - ratio;

    // Gradient: czerwony ‚Üí ≈º√≥≈Çty ‚Üí zielony
    let r, g, b = 0;
    if (ratio < 0.5) {
      const localRatio = ratio / 0.5;
      r = 255;
      g = Math.round(255 * localRatio);
    } else {
      const localRatio = (ratio - 0.5) / 0.5;
      r = Math.round(255 * (1 - localRatio));
      g = 255;
    }
    return `rgb(${r},${g},${b})`;
  }

  // Kolorowanie ka≈ºdej kom√≥rki i ujednolicone formatowanie
  rowsArray.forEach(row => {
    const gainCell = row.cells[colGainIndex];
    const lossCell = row.cells[colLossIndex];
    const percentCell = row.cells[colPercentIndex];
    
    // Wymagane sprawdzenie istnienia kom√≥rki dla bezpiecze≈Ñstwa
    if (!gainCell || !lossCell || !percentCell) return;

    let gain = parseFloat(gainCell.innerText.replace("%","").replace(",",".")) || 0;
    let loss = parseFloat(lossCell.innerText.replace("%","").replace(",",".")) || 0;
    let percent = parseFloat(percentCell.innerText.replace("%","").replace(",",".")) || 0;

    // Ujednolicone formatowanie
    gainCell.innerText = formatNumber(gain, 1);
    lossCell.innerText = formatNumber(loss, 1);
    percentCell.innerText = formatNumber(percent, 1, true);

    // Gradient dla ≈õredniego zysku
    gainCell.style.color = interpolateColor(gain, minGain, maxGain, false);

    // Gradient dla ≈õredniej straty
    lossCell.style.color = interpolateColor(loss, minLoss, maxLoss, true);

// Kolorowanie ostatniej kolumny % straconego ≈Çupu
if (!isNaN(percent)) {
  if (percent <= 3.0) {
    percentCell.style.backgroundColor = "#34a853"; // zielony
    percentCell.style.color = "#ffffff"; // bia≈Çy tekst
  } else if (percent > 3.0 && percent <= 10.0) {
    percentCell.style.backgroundColor = "#fbbc04"; // ≈º√≥≈Çty
    percentCell.style.color = "#121212"; // czarny/ciemny tekst
  } else if (percent > 10.0) {
    percentCell.style.backgroundColor = "#ea4335"; // czerwony
    percentCell.style.color = "#ffffff"; // bia≈Çy tekst
  }
} else {
  percentCell.style.backgroundColor = "";
  percentCell.style.color = "";
}
  });
} 

// ===================================================================
// FUNKCJONALNO≈öƒÜ: PODSUMOWANIE ZAKON√ìW (ZMODYFIKOWANA)
// ===================================================================

const GUILD_SUMMARY_STATS = [
  "≈Åup zdobyty",
  "≈Åup stracony",
  "Wygranych turniej√≥w", // <<< DODANA NOWA STATYSTYKA
  "Zwyciƒôstwa",
  "Remisy",
  "Pora≈ºki"
];

function showGuildSummary() {
  const resultDiv = document.getElementById("result");
  const summaryTable = document.getElementById("summaryTable");
  const summaryH2 = resultDiv.querySelector('h2[style*="ffd28a"]');
  const summaryBtn = document.getElementById("showSummaryBtn");

  // --- 1. Logika ukrywania/prze≈ÇƒÖczania ---
  if (guildSummaryVisible && summaryTable && summaryH2) {
    summaryTable.remove();
    summaryH2.remove();
    guildSummaryVisible = false;
    summaryBtn.textContent = "Podsumowanie Zakon√≥w";
    return;
  }
  
  // Ustawienie tekstu przycisku na "Ukryj" przed przetwarzaniem
  summaryBtn.textContent = "Ukryj podsumowanie zakon√≥w";


  const allHTML = document.getElementById("inputHTML").value;
  let allResults = [];
  let allResultsRaw = [];

  // ... (Logika parsowania i deduplikacji - bez zmian) ...
  if (allHTML.trim()) {
    const profilesRaw = allHTML.split(/(?=<!DOCTYPE html PUBLIC)/i);
    for (const profRaw of profilesRaw) {
        if (!profRaw.trim()) continue;
        try { const parsed = parseSingleProfile(profRaw); allResultsRaw.push(parsed); } catch {}
    }
    
    const uniqueResults = {};
    for (const player of allResultsRaw) {
        const canonical = getCanonicalNick(player.nick);
        if (!uniqueResults[canonical]) {
            uniqueResults[canonical] = player;
        }
    }
    allResults = Object.values(uniqueResults);
    
    if (allResults.length > 0) {
        window.lastResults = allResults;
    } else if (window.lastResults && window.lastResults.length > 0) {
        allResults = window.lastResults;
    }

  } else if (window.lastResults && window.lastResults.length > 0) {
    allResults = window.lastResults;
  }
  
  if (allResults.length === 0) {
     const msg = "<p style='color: #ea4335; font-weight: bold;'>Brak danych do analizy. Wklej dane profili lub wyciƒÖgnij je u≈ºywajƒÖc 'WyciƒÖgnij dane/Por√≥wnaj'.</p>";
     const oldMsg = resultDiv.querySelector('p[style*="ea4335"]');
     if (oldMsg) oldMsg.remove();
     resultDiv.prepend(document.createRange().createContextualFragment(msg));
     guildSummaryVisible = false; 
     summaryBtn.textContent = "Podsumowanie Zakon√≥w";
     return; 
  }

  const oldMsg = resultDiv.querySelector('p[style*="ea4335"]');
  if (oldMsg) oldMsg.remove();

  // ≈Åadowanie aktywnego checkpointa
  const activeCheckpointKey = getActiveCheckpointKey();
  const checkpoint = loadCheckpointData(activeCheckpointKey);
  const checkpointBase = checkpoint.base || {};
  const checkpointStats = checkpoint.stats || {};
  
  const allSummaryKeys = [...attrKeys, ...GUILD_SUMMARY_STATS];
  const guildMap = {}; 

  // Inicjalizacja kluczy dla wszystkich zakon√≥w
  for (const player of allResults) {
    const playerZakon = player.zakon ? player.zakon.trim() : 'Brak Zakonu';
    if (!guildMap[playerZakon]) {
        guildMap[playerZakon] = { sum: { members: 0, activeMembers: 0, totalRaisedAllAttrs: 0, totalFights: 0 } };
        for (const key of allSummaryKeys) {
            guildMap[playerZakon].sum[key] = 0;
        }
    }
  }

  // ===== PƒòTLA PRZEZ WYNIKI I AGREGACJA Z POPRAWKƒÑ NA NOWYCH GRACZY =====
  for (const player of allResults) {
    const canonical = getCanonicalNick(player.nick);
    const prevStats = checkpointStats[canonical] || {};
    const prevBase = checkpointBase[canonical] || {};
    
    const playerZakon = player.zakon ? player.zakon.trim() : 'Brak Zakonu';
    const guildSum = guildMap[playerZakon].sum;

    guildSum.members++; // Liczba cz≈Çonk√≥w zakonu (obecny stan)

    // KLUCZOWA POPRAWKA: Sprawdzamy, czy gracz istnia≈Ç w checkpoincie (dla liczenia delty)
    const playerExistedInCheckpoint = checkpointBase.hasOwnProperty(canonical);

    if (playerExistedInCheckpoint) {
        let playerRaisedAttrs = 0;
        let playerFights = 0;
        
        // Agregacja szczeg√≥≈Çowych atrybut√≥w bazowych (Si≈Ça, Zrƒôczno≈õƒá, itd.)
        for (const attr of attrKeys) {
            const basePrev = prevBase[attr] ?? 0;
            const diff = (player.base[attr] ?? 0) - basePrev;
            guildSum[attr] += diff;
            playerRaisedAttrs += diff;
        }
        
        // Agregacja pozosta≈Çych statystyk (≈Åup, Walki, Turnieje)
        for (const stat of GUILD_SUMMARY_STATS) { 
            const val = player.stats[stat] ?? 0;
            const statPrev = prevStats[stat] ?? 0;
            const diff = val - statPrev;
            guildSum[stat] += diff;
            if (stat === "Zwyciƒôstwa" || stat === "Remisy" || stat === "Pora≈ºki") {
                playerFights += diff;
            }
        }
        
        // NOWA LOGIKA: Liczenie aktywnych graczy
        // Dodano sumowanie Wygranych Turniej√≥w do kryterium aktywno≈õci
        if (playerRaisedAttrs > 0 || playerFights > 0 || (player.stats["≈Åup zdobyty"] - (prevStats["≈Åup zdobyty"] ?? 0)) > 0 || (player.stats["≈Åup stracony"] - (prevStats["≈Åup stracony"] ?? 0)) > 0 || (player.stats["Wygranych turniej√≥w"] - (prevStats["Wygranych turniej√≥w"] ?? 0)) > 0) {
            guildSum.activeMembers++;
        }
        
        // Zapis sumy do p√≥≈∫niejszego filtrowania
        guildSum.totalRaisedAllAttrs += playerRaisedAttrs;
        guildSum.totalFights += playerFights;

    }
    // Je≈õli gracz nie istnia≈Ç w checkpoincie, jego wk≈Çad w delta wynosi 0
  }

  // ===== FILTROWANIE ZAKON√ìW BEZ AKTYWNO≈öCI =====
  const activeGuilds = Object.keys(guildMap).filter(guildKey => {
      const sum = guildMap[guildKey].sum;
      // Zakon jest aktywny, je≈õli ma podniesione atrybuty (totalRaisedAllAttrs > 0) 
      // lub jakƒÖkolwiek aktywno≈õƒá w walkach/≈Çupach (totalFights > 0 lub ≈Åup > 0)
      return sum.totalRaisedAllAttrs > 0 || sum.totalFights > 0 || sum["≈Åup zdobyty"] > 0 || sum["≈Åup stracony"] > 0 || sum["Wygranych turniej√≥w"] > 0;
  });

  // ===== GENEROWANIE TABELI WYNIK√ìW =====
  html = `<h2 style="color: #ffd28a;">Podsumowanie Zakon√≥w (Œî od checkpointa)</h2>`;
  // DODANA NOWA KOLUMNA 'Aktywni Gracze'
  html += `<table id="summaryTable"><thead><tr><th>Zakon</th><th>Liczba Graczy</th><th>Aktywni Gracze</th>`;
  
  // Nag≈Ç√≥wki dla atrybut√≥w
  for (const attr of attrKeys) {
      const disp = displayNames[attr] || attr;
      html += `<th>${disp} (Œî)</th>`;
  }
  
  // Nag≈Ç√≥wek dla ≈ÇƒÖcznej sumy atrybut√≥w
  html += `<th>≈ÅƒÖcznie Atrybut√≥w (Œî)</th>`; 
  
  // Nag≈Ç√≥wki dla pozosta≈Çych statystyk
  const otherStats = GUILD_SUMMARY_STATS.filter(stat => stat !== "Wygranych turniej√≥w");
  for (const stat of otherStats) {
      html += `<th>${displayNames[stat] || stat} (Œî)</th>`;
  }
  
  // KOLUMNA TURNIEJ√ìW NA KO≈ÉCU
  html += `<th>${displayNames["Wygranych turniej√≥w"] || "Wygranych turniej√≥w"} (Œî)</th>`;
  
  html += `<th>≈ÅƒÖczna Liczba Walk (Œî)</th></tr></thead><tbody>`;

  // Sortowanie AKTYWNYCH zakon√≥w po ≈Åupie Zdobyty (Œî) - malejƒÖco (domy≈õlnie)
  const sortedActiveGuilds = activeGuilds.sort((a, b) => {
    return guildMap[b].sum["≈Åup zdobyty"] - guildMap[a].sum["≈Åup zdobyty"];
  });

  for (const guildKey of sortedActiveGuilds) { // U≈ºycie aktywnie posortowanej tablicy
    const sum = guildMap[guildKey].sum;
    
    // Obliczenie sumy przyrost√≥w atrybut√≥w dla wy≈õwietlenia
    let totalRaisedAllAttrs = 0; 
    for (const attr of attrKeys) {
        totalRaisedAllAttrs += sum[attr];
    }
    
    html += `<tr><td>${guildKey}</td><td>${sum.members}</td><td>${sum.activeMembers}</td>`; // DODANA NOWA KOM√ìRKA
    
    // Kolumny dla poszczeg√≥lnych atrybut√≥w
    for (const attr of attrKeys) {
        const attrDiff = sum[attr];
        html += `<td>${formatDiff(attrDiff, attr)}</td>`;
    }

    // ≈ÅƒÖczna suma atrybut√≥w (Œî)
    const totalRaisedHtml = formatDiff(totalRaisedAllAttrs, 'Staty'); 
    html += `<td>${totalRaisedHtml}</td>`;

    // Kolumny pozosta≈Çych statystyk
    for (const stat of otherStats) {
        html += `<td>${formatDiff(sum[stat], stat)}</td>`;
    }
    
    // KOLUMNA TURNIEJ√ìW
    html += `<td>${formatDiff(sum["Wygranych turniej√≥w"], "Wygranych turniej√≥w")}</td>`;
    
    // ≈ÅƒÖczna liczba walk (Œî)
    const totalFights = sum["Zwyciƒôstwa"] + sum["Remisy"] + sum["Pora≈ºki"];
    const totalFightsHtml = totalFights === 0 ? `<span class="zero-diff">0</span>` : `<span style="color:#ff00ff;font-weight:bold;">${totalFights}</span>`;
    html += `<td>${totalFightsHtml}</td>`;
    
    html += `</tr>`;
  }
  
  html += `</tbody></table>`;
  
  // Wstawienie wynik√≥w
  const summaryDiv = document.createElement('div');
  summaryDiv.innerHTML = html;
  
  // Usuniƒôcie poprzedniego podsumowania, je≈õli istnieje
  if (summaryH2) summaryH2.remove();
  if (summaryTable) summaryTable.remove();

  // Dodanie nowego podsumowania na poczƒÖtek div#result
  if (summaryDiv.firstChild) {
    resultDiv.prepend(summaryDiv.firstChild.nextElementSibling); // Tabela
    resultDiv.prepend(summaryDiv.firstChild); // Nag≈Ç√≥wek
    guildSummaryVisible = true;
  }
  
  // Dodanie podstawowego stylu (bez zmian)
  const styleId = 'summaryTableStyle';
  if (!document.getElementById(styleId)) {
      const style = document.createElement('style');
      style.id = styleId;
      style.type = 'text/css';
      style.innerHTML = `
        #summaryTable { 
            margin-bottom: 20px; 
            width: 100%; 
            border-collapse: collapse;
            font-size: 0.9em;
            white-space: nowrap;
        }
        #summaryTable th, #summaryTable td { 
            border: 1px solid #333; 
            padding: 10px; 
            text-align: center;
        }
        #summaryTable th { 
            background-color: #fbbc04; 
            color: #121212; 
            font-weight: bold;
            position: sticky;
            top: 0;
            z-index: 2;
            cursor: pointer; /* Dodanie kursora dla sortowania */
        }
        #summaryTable tbody tr:nth-child(odd) { background-color: #000; }
        #summaryTable tbody tr:nth-child(even) { background-color: #1a1a1a; }
        #summaryTable td { color: #f0f0f0; }
      `;
      document.getElementsByTagName('head')[0].appendChild(style);
  }
  
  // --- 3. Dodanie segregowania kolumn dla nowej tabeli ---
  addSummaryTableSorting('summaryTable');
}

// Funkcja sortowania specjalnie dla tabeli podsumowania
function addSummaryTableSorting(tableId) {
  const table = document.getElementById(tableId);
  if (!table) return;

  const headers = table.querySelectorAll("th");
  headers.forEach((header, index) => {
    header.addEventListener("click", () => {
      const tbody = table.tBodies[0];
      const rows = Array.from(tbody.querySelectorAll("tr"));
      const asc = !header.classList.contains("asc");

      const parseNumberFrom = (text) => {
        if (!text) return NaN;
        // Akceptuje + / - / , / cyfry / . i usuwa resztƒô (np. Œî)
        const cleaned = text.replace(/[^\d\-,.]/g, "").replace(",", ".");
        if (cleaned === "" || cleaned === "-" || cleaned === "+") return NaN;
        return parseFloat(cleaned);
      };

      rows.sort((a, b) => {
        const Araw = (a.cells[index] && a.cells[index].textContent) ? a.cells[index].textContent.trim() : "";
        const Braw = (b.cells[index] && b.cells[index].textContent) ? b.cells[index].textContent.trim() : "";

        const numA = parseNumberFrom(Araw);
        const numB = parseNumberFrom(Braw);
        const isNumeric = !isNaN(numA) && !isNaN(numB);

        if (isNumeric) {
          return asc ? numA - numB : numB - numA;
        } else {
          // Sortowanie tekstowe (dla "Zakon")
          return asc ? Araw.localeCompare(Braw, undefined, { sensitivity: "base" }) 
                     : Braw.localeCompare(Araw, undefined, { sensitivity: "base" });
        }
      });

      // Aktualizacja klas sortowania (asc/desc)
      headers.forEach(h => h.classList.remove("asc", "desc"));
      header.classList.add(asc ? "asc" : "desc");

      // wstawienie wierszy w nowej kolejno≈õci
      rows.forEach(row => tbody.appendChild(row));
    });
  });
}
</script>

</body>
</html>
